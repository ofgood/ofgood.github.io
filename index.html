<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0" />
    <title>智能排班表（1上2休）</title>
    <link rel="stylesheet" href="./assets/reset.css" />
    <link rel="stylesheet" href="./assets/style.css" />
    <style>
      :root {
        --primary-color: #1890ff;
        --success-color: #52c41a;
        --warning-color: #faad14;
        --error-color: #f5222d;
        --text-color: #333;
        --bg-color: #f0f2f5;
        --card-bg: #fff;
        --border-radius: 8px;
        --shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.03),
          0 1px 6px -1px rgba(0, 0, 0, 0.02),
          0 2px 4px 0 rgba(0, 0, 0, 0.02);
      }

      body {
        background-color: var(--bg-color);
        color: var(--text-color);
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI",
          Roboto, "Helvetica Neue", Arial, sans-serif;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
      }

      h1 {
        text-align: center;
        margin-bottom: 24px;
        color: #1f1f1f;
        font-weight: 600;
      }

      h1 small {
        font-size: 0.5em;
        color: #888;
        font-weight: normal;
      }

      /* Cards */
      .card {
        background: var(--card-bg);
        border-radius: var(--border-radius);
        box-shadow: var(--shadow);
        padding: 10px;
        margin-bottom: 16px;
      }

      /* Controls */
      .controls-wrapper {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 20px;
        align-items: end;
      }

      .control-group {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .control-group label {
        font-size: 14px;
        font-weight: 500;
        color: #555;
      }

      .control-group input {
        padding: 8px 12px;
        border: 1px solid #d9d9d9;
        border-radius: 4px;
        font-size: 14px;
        transition: all 0.3s;
      }

      .control-group input:focus {
        border-color: var(--primary-color);
        outline: none;
        box-shadow: 0 0 0 2px rgba(24, 144, 255, 0.2);
      }

      .btn {
        padding: 8px 16px;
        border-radius: 4px;
        border: none;
        cursor: pointer;
        font-size: 14px;
        font-weight: 500;
        transition: all 0.3s;
      }

      .btn-primary {
        background: var(--primary-color);
        color: white;
      }

      .btn-primary:hover {
        background: #40a9ff;
      }

      .btn-secondary {
        background: #fff;
        border: 1px solid #d9d9d9;
        color: #666;
      }

      .btn-secondary:hover:not(:disabled) {
        color: var(--primary-color);
        border-color: var(--primary-color);
      }

      .btn:disabled {
        background: #f5f5f5;
        color: #bbb;
        cursor: not-allowed;
        border-color: #d9d9d9;
      }

      /* Prediction Result */
      .predict-result {
        margin-top: 12px;
        padding: 12px;
        background: #f6ffed;
        border: 1px solid #b7eb8f;
        border-radius: 4px;
        color: #389e0d;
        display: none;
      }
      .predict-result.show {
        display: block;
      }

      /* Calendar Grid */
      .calendar-wrap {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
        gap: 16px;
      }

      .month-card {
        background: #fff;
        border-radius: var(--border-radius);
        border: 1px solid #f0f0f0;
        overflow: hidden;
      }

      .month-header {
        background: #fafafa;
        padding: 8px;
        text-align: center;
        font-weight: 600;
        border-bottom: 1px solid #f0f0f0;
        font-size: 14px;
      }

      .month-grid {
        display: grid;
        grid-template-columns: repeat(7, 1fr);
        padding: 4px;
        gap: 2px;
      }

      .weekday-label {
        text-align: center;
        font-size: 12px;
        color: #999;
        padding: 4px 0;
      }

      .day-cell {
        aspect-ratio: 0.85; /* Slightly taller to fit content */
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: space-between; /* Distribute space */
        border-radius: 4px;
        font-size: 12px;
        cursor: default;
        position: relative;
        padding: 4px 2px 2px 2px;
        overflow: hidden; /* Prevent spillover */
      }

      .day-num {
        font-weight: 500;
        font-size: 13px;
        align-self: flex-start; /* Align to left */
        margin-left: 2px;
        line-height: 1;
      }

      .day-status {
        font-size: 11px;
        font-weight: 500;
        margin: 2px 0;
        z-index: 1;
      }

      /* Status Colors */
      .state-0 {
        /* Work */
        background-color: #f6ffed;
        color: #389e0d;
        border: 1px solid #b7eb8f;
      }

      .state-1 {
        /* Rest 1 */
        background-color: #f5f5f5;
        color: #8c8c8c;
        border: 1px solid #d9d9d9;
      }

      .state-2 {
        /* Rest 2 */
        background-color: #fffbe6;
        color: #d46b08;
        border: 1px solid #ffe58f;
      }

      .state-today {
        box-shadow: 0 0 0 2px var(--primary-color);
        z-index: 2;
      }

      /* Holiday Markers */
      .holiday-info {
        position: absolute;
        top: 2px;
        right: 2px;
        display: flex;
        flex-direction: column;
        align-items: flex-end;
        gap: 1px;
      }

      .holiday-badge {
        padding: 1px 2px;
        border-radius: 2px;
        color: #fff;
        font-size: 10px;
        line-height: 1;
        transform: scale(0.85);
        transform-origin: top right;
      }

      .badge-holiday {
        background-color: #ff4d4f;
      }

      .badge-work {
        background-color: #595959;
      }

      .wage-tag {
        color: #f5222d;
        font-weight: bold;
        font-size: 10px;
        transform: scale(0.8);
        transform-origin: top right;
        line-height: 1;
      }

      .holiday-name {
        width: 100%;
        text-align: center;
        font-size: 10px;
        color: #ff4d4f;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        line-height: 1.2;
        transform: scale(0.9);
      }

      /* Responsive adjustments */
      @media (max-width: 600px) {
        .controls-wrapper {
          grid-template-columns: 1fr;
        }
        .calendar-wrap {
          grid-template-columns: 1fr; /* Force single column on mobile */
          gap: 12px;
        }
        .container {
          padding: 10px;
        }
        .card {
          padding: 15px;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h3>
        智能排班表
        <small>（上1休2）</small>
      </h3>
      <div class="card">
        <div class="controls-wrapper">
          <div class="control-group">
            <label for="startDate">开始排班日期 (上班第1天)</label>
            <input type="date" id="startDate" />
          </div>
          <div class="control-group">
            <label for="days">生成天数</label>
            <input
              type="number"
              id="days"
              min="1"
              max="730"
              value="90" />
          </div>
          <div
            class="control-group"
            style="
              flex-direction: row;
              align-items: flex-end;
              gap: 10px;
            ">
            <button id="generate" class="btn btn-primary">
              生成日历
            </button>
            <button id="exportCsv" class="btn btn-secondary" disabled>
              导出 CSV
            </button>
          </div>
        </div>
      </div>

      <div class="card">
        <div class="controls-wrapper">
          <div class="control-group">
            <label for="predictDate">日期查询/预测</label>
            <div style="display: flex; gap: 10px">
              <input type="date" id="predictDate" style="flex: 1" />
              <button id="predictStatus" class="btn btn-primary">
                查询
              </button>
            </div>
          </div>
        </div>
        <div id="predictResult" class="predict-result"></div>
      </div>

      <div class="calendar-wrap" id="calendarWrap"></div>
    </div>

    <script>
      let holidayData = {}; // Store holiday data: { "YYYY-MM-DD": { holiday: bool, name: str, wage: int, ... } }

      function fmtDate(d) {
        const y = d.getFullYear();
        const m = (d.getMonth() + 1).toString().padStart(2, "0");
        const day = d.getDate().toString().padStart(2, "0");
        const wk = ["日", "一", "二", "三", "四", "五", "六"][
          d.getDay()
        ];
        return `${y}-${m}-${day} 周${wk}`;
      }

      function formatDateKey(d) {
        const m = (d.getMonth() + 1).toString().padStart(2, "0");
        const day = d.getDate().toString().padStart(2, "0");
        return `${m}-${day}`;
      }

      // Fetch holiday data
      async function fetchHolidays(year) {
        // We try to fetch for the requested year.
        // If we already have data for this year, maybe skip?
        // But the user might want fresh data. For simplicity, we fetch.
        // Note: timor.tech API structure is { "code": 0, "holiday": { "01-01": { ... } } }
        // The keys are MM-DD.

        try {
          const res = await fetch(
            `https://timor.tech/api/holiday/year/${year}/`
          );
          const json = await res.json();
          if (json.code === 0 && json.holiday) {
            // Store with full date keys to avoid year conflict if we cache multiple years
            Object.entries(json.holiday).forEach(([key, val]) => {
              holidayData[`${year}-${key}`] = val;
            });
          }
        } catch (e) {
          console.error("Failed to fetch holidays:", e);
          // Fallback or silent fail
        }
      }

      // Helper to fetch for a range of years
      async function fetchHolidaysForRange(startDate, days) {
        const startYear = startDate.getFullYear();
        const endDate = addDays(startDate, days);
        const endYear = endDate.getFullYear();

        const promises = [];
        for (let y = startYear; y <= endYear; y++) {
          // Basic check if we already have some data for this year could be added,
          // but here we just fetch to be safe.
          promises.push(fetchHolidays(y));
        }
        await Promise.all(promises);
      }

      function addDays(d, n) {
        const x = new Date(d.getTime());
        x.setDate(x.getDate() + n);
        return x;
      }

      function daysBetween(a, b) {
        // Reset time part to ensure correct day calculation
        const da = new Date(
          a.getFullYear(),
          a.getMonth(),
          a.getDate()
        );
        const db = new Date(
          b.getFullYear(),
          b.getMonth(),
          b.getDate()
        );
        return Math.round((db - da) / 86400000);
      }

      function statusLabel(r) {
        if (r === 0) return "上班";
        if (r === 1) return "休(1)";
        return "休(2)";
      }

      function generateData(startDate, days) {
        const dates = [];
        for (let i = 0; i < days; i++)
          dates.push(addDays(startDate, i));

        const states = dates.map(d => {
          const diff = daysBetween(startDate, d);
          // diff can be negative if d is before startDate
          // Ensure positive modulus for negative numbers
          const r = ((diff % 3) + 3) % 3;
          return r;
        });
        return { dates, states };
      }

      function renderCalendar(data) {
        const wrap = document.getElementById("calendarWrap");
        wrap.innerHTML = "";

        if (data.dates.length === 0) return;

        // Group by Month
        const months = {};
        const today = new Date();
        today.setHours(0, 0, 0, 0);

        data.dates.forEach((d, i) => {
          const key = `${d.getFullYear()}-${String(
            d.getMonth() + 1
          ).padStart(2, "0")}`;
          if (!months[key]) months[key] = [];
          months[key].push({ date: d, state: data.states[i] });
        });

        Object.keys(months).forEach(key => {
          const monthData = months[key];
          const [year, month] = key.split("-");

          const monthCard = document.createElement("div");
          monthCard.className = "month-card";

          const header = document.createElement("div");
          header.className = "month-header";
          header.textContent = `${year}年 ${month}月`;
          monthCard.appendChild(header);

          const grid = document.createElement("div");
          grid.className = "month-grid";

          // Weekday headers
          const weekDays = ["日", "一", "二", "三", "四", "五", "六"];
          weekDays.forEach(wd => {
            const el = document.createElement("div");
            el.className = "weekday-label";
            el.textContent = wd;
            grid.appendChild(el);
          });

          // Empty slots for the first day of the month
          const firstDate = monthData[0].date;
          // We need to know the day of the week of the 1st day of this month
          // Note: monthData[0] might not be the 1st of the month if the range starts mid-month
          // But usually for a calendar view, we might want to align it.
          // However, to keep it simple and showing only requested range, we align based on the first requested date of that month.
          // BETTER UX: Align based on the actual 1st day of the month, even if not in range?
          // Let's stick to standard calendar alignment:
          const firstDayOfMonth = new Date(
            firstDate.getFullYear(),
            firstDate.getMonth(),
            1
          ).getDay();

          // But wait, if our data doesn't start on the 1st, we should still align correctly.
          // We need to pad from the 1st of the month up to the first actual data point?
          // Or just pad empty cells until the weekday of the first data point.
          // Standard calendar: Pad until the weekday of the 1st of the month.
          // If our data starts on the 5th, we should probably still render 1-4 as empty or "out of range"?
          // Let's just pad to the weekday of the first *data point* for now to avoid complexity,
          // OR better: Pad to the weekday of the 1st of the month, and render empty cells for days before start date.

          // Let's do simple alignment: Just pad empty cells until the weekday of the first data item shown.
          const startDay = firstDate.getDay();
          for (let i = 0; i < startDay; i++) {
            const empty = document.createElement("div");
            grid.appendChild(empty);
          }

          monthData.forEach(item => {
            const cell = document.createElement("div");
            cell.className = `day-cell state-${item.state}`;

            // Check if today
            const dateKey = `${item.date.getFullYear()}-${String(
              item.date.getMonth() + 1
            ).padStart(2, "0")}-${String(
              item.date.getDate()
            ).padStart(2, "0")}`;
            const isToday = item.date.getTime() === today.getTime();
            if (isToday) cell.classList.add("state-today");

            // Check holiday info
            const hInfo = holidayData[dateKey];
            let holidayHtml = "";
            if (hInfo) {
              const isHoliday = hInfo.holiday;
              const badgeClass = isHoliday
                ? "badge-holiday"
                : "badge-work";
              const badgeText = isHoliday ? "休" : "班";
              const nameText = hInfo.name;

              holidayHtml = `
                        <div class="holiday-info">
                            <span class="holiday-badge ${badgeClass}">${badgeText}</span>
                        </div>
                        <div class="holiday-name" title="${nameText}">${nameText}</div>
                    `;
            }

            cell.innerHTML = `
                    <span class="day-num">${item.date.getDate()}</span>
                    <span class="day-status">${statusLabel(
                      item.state
                    )}</span>
                    ${holidayHtml}
                `;
            grid.appendChild(cell);
          });

          monthCard.appendChild(grid);
          wrap.appendChild(monthCard);
        });

        document.getElementById("exportCsv").disabled = false;
      }

      function toCsv(data) {
        const head = ["日期", ...data.dates.map(fmtDate)].join(",");
        const row = [
          "状态",
          ...data.states.map(r => statusLabel(r)),
        ].join(",");
        return [head, row].join("\n");
      }

      function downloadCsv(filename, content) {
        const blob = new Blob(["\ufeff" + content], {
          type: "text/csv;charset=utf-8;",
        });
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(a.href);
      }

      document.addEventListener("DOMContentLoaded", function () {
        const sd = document.getElementById("startDate");
        const today = new Date();
        sd.value = [
          today.getFullYear(),
          (today.getMonth() + 1).toString().padStart(2, "0"),
          today.getDate().toString().padStart(2, "0"),
        ].join("-");

        // Default generation
        document.getElementById("generate").click();

        // Listeners
        document
          .getElementById("generate")
          .addEventListener("click", async function () {
            const startStr =
              document.getElementById("startDate").value;
            if (!startStr) return;

            const start = new Date(startStr);
            const days =
              parseInt(document.getElementById("days").value, 10) ||
              90;

            // Fetch holidays first
            await fetchHolidaysForRange(start, days);

            const data = generateData(start, days);
            renderCalendar(data);
          });

        document
          .getElementById("startDate")
          .addEventListener("change", function () {
            // Auto regenerate? Or just wait for click. Let's auto-regenerate for better UX.
            document.getElementById("generate").click();
          });

        document
          .getElementById("exportCsv")
          .addEventListener("click", function () {
            const start = new Date(
              document.getElementById("startDate").value
            );
            const days =
              parseInt(document.getElementById("days").value, 10) ||
              90;
            const data = generateData(start, days);
            const csv = toCsv(data);
            downloadCsv("智能排班.csv", csv);
          });

        document
          .getElementById("predictStatus")
          .addEventListener("click", function () {
            const start = new Date(
              document.getElementById("startDate").value
            );
            const targetStr =
              document.getElementById("predictDate").value;
            const resEl = document.getElementById("predictResult");

            if (!targetStr) {
              resEl.textContent = "请先选择预测日期";
              resEl.classList.add("show");
              return;
            }
            const target = new Date(targetStr);
            const diff = daysBetween(start, target);
            const r = ((diff % 3) + 3) % 3;

            resEl.innerHTML = `<strong>${fmtDate(
              target
            )}</strong> 的状态是：<strong>${statusLabel(r)}</strong>`;
            resEl.classList.add("show");
          });
      });
    </script>
  </body>
</html>
